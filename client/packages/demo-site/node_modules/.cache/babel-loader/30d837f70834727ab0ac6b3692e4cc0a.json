{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useQuery = exports.useFlowerBI = void 0;\n\nvar react_1 = require(\"react\");\n\nvar flowerbi_1 = require(\"flowerbi\");\n\nvar json_stable_stringify_1 = __importDefault(require(\"json-stable-stringify\"));\n/**\n * A custom React hook that evaluates to the result of a\n * [Query](../flowerbi/interfaces/query.html), making it easy to perform a\n * query from within a component.\n *\n * The returned object has a strongly-typed `records` array, and optionally\n * a `totals` object. It has a `state` of type {@link UseQueryState} that\n * can be used to show a loading indicator.\n *\n * @param fetch The fetch function to use.\n * @param query The [Query](../flowerbi/interfaces/query.html) specification.\n * @param dependencies Optionally, a list of one or more other queries whose\n * results are used to build this query, so we wait for them before executing,\n * and optionally short-circuit to an empty result if the dependency is empty.\n */\n\n\nfunction useFlowerBI(fetch, query, dependencies) {\n  var queryJson = (0, flowerbi_1.jsonifyQuery)(query);\n\n  var _a = (0, react_1.useState)(\"init\"),\n      state = _a[0],\n      setState = _a[1];\n\n  var _b = (0, react_1.useState)({\n    records: []\n  }),\n      result = _b[0],\n      setResult = _b[1];\n\n  (0, react_1.useEffect)(function () {\n    var disposed = false; // discard stale results\n\n    if (dependencies === null || dependencies === void 0 ? void 0 : dependencies.length) {\n      // if any not ready, neither are we\n      if (dependencies.some(function (x) {\n        return x.dependency.state !== \"ready\";\n      })) {\n        if (state !== \"init\") {\n          setState(\"refresh\");\n        }\n\n        return;\n      } // if any with option nonEmpty produced empty result, so do we\n\n\n      if (dependencies.filter(function (x) {\n        return !!x.nonEmpty;\n      }).some(function (x) {\n        return !x.dependency.records.length;\n      })) {\n        setState(\"ready\");\n        setResult({\n          records: []\n        });\n        return;\n      }\n    }\n\n    if (state !== \"init\") {\n      setState(\"refresh\");\n    }\n\n    fetch(queryJson).then(function (x) {\n      if (!disposed) {\n        setState(\"ready\");\n        setResult(x);\n      }\n    }, function () {\n      if (!disposed) {\n        setState(\"error\");\n      }\n    });\n    return function () {\n      disposed = true;\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [fetch, (0, json_stable_stringify_1.default)(queryJson)]);\n  return __assign(__assign({}, (0, flowerbi_1.expandQueryResult)(query.select, result, query.calculations)), {\n    state: state\n  });\n}\n\nexports.useFlowerBI = useFlowerBI;\n/**\n * Alias of useFlowerBI for backward compatibility.\n */\n\nexports.useQuery = useFlowerBI;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;AAkCA;;;;;;;;;;;;;;;;;AAeA,SAAgBA,WAAhB,CACIC,KADJ,EAEIC,KAFJ,EAGIC,YAHJ,EAGoC;AAEhC,MAAMC,SAAS,GAAG,6BAAaF,KAAb,CAAlB;;AAEM,WAAoB,sBAAwB,MAAxB,CAApB;AAAA,MAACG,KAAK,QAAN;AAAA,MAAQC,QAAQ,QAAhB;;AACA,WAAsB,sBAA0B;AAAEC,WAAO,EAAE;AAAX,GAA1B,CAAtB;AAAA,MAACC,MAAM,QAAP;AAAA,MAASC,SAAS,QAAlB;;AAEN,yBAAU;AACN,QAAIC,QAAQ,GAAG,KAAf,CADM,CACgB;;AAEtB,QAAIP,YAAY,SAAZ,gBAAY,WAAZ,GAAY,MAAZ,eAAY,CAAEQ,MAAlB,EAA0B;AACtB;AACA,UAAIR,YAAY,CAACS,IAAb,CAAkB,UAACC,CAAD,EAAE;AAAK,gBAAC,CAACC,UAAF,CAAaT,KAAb,KAAuB,OAAvB;AAA8B,OAAvD,CAAJ,EAA8D;AAC1D,YAAIA,KAAK,KAAK,MAAd,EAAsB;AAClBC,kBAAQ,CAAC,SAAD,CAAR;AACH;;AACD;AACH,OAPqB,CAStB;;;AACA,UAAIH,YAAY,CAACY,MAAb,CAAoB,UAACF,CAAD,EAAE;AAAK,gBAAC,CAACA,CAAC,CAACG,QAAJ;AAAY,OAAvC,EAAyCJ,IAAzC,CAA8C,UAACC,CAAD,EAAE;AAAK,gBAACA,CAAC,CAACC,UAAF,CAAaP,OAAb,CAAqBI,MAAtB;AAA4B,OAAjF,CAAJ,EAAwF;AACpFL,gBAAQ,CAAC,OAAD,CAAR;AACAG,iBAAS,CAAC;AAAEF,iBAAO,EAAE;AAAX,SAAD,CAAT;AACA;AACH;AACJ;;AAED,QAAIF,KAAK,KAAK,MAAd,EAAsB;AAClBC,cAAQ,CAAC,SAAD,CAAR;AACH;;AAEDL,SAAK,CAACG,SAAD,CAAL,CAAiBa,IAAjB,CACI,UAACJ,CAAD,EAAE;AACE,UAAI,CAACH,QAAL,EAAe;AACXJ,gBAAQ,CAAC,OAAD,CAAR;AACAG,iBAAS,CAACI,CAAD,CAAT;AACH;AACJ,KANL,EAOI;AACI,UAAI,CAACH,QAAL,EAAe;AACXJ,gBAAQ,CAAC,OAAD,CAAR;AACH;AACJ,KAXL;AAcA,WAAO;AACHI,cAAQ,GAAG,IAAX;AACH,KAFD,CAtCM,CAyCN;AACH,GA1CD,EA0CG,CAACT,KAAD,EAAQ,qCAAgBG,SAAhB,CAAR,CA1CH;AA4CA,+BAAY,kCAAwBF,KAAK,CAACgB,MAA9B,EAAsCV,MAAtC,EAA8CN,KAAK,CAACiB,YAApD,CAAZ,GAA6E;AAAEd,SAAK;AAAP,GAA7E;AACH;;AAvDDe;AAyDA;;;;AAGaA,mBAAWpB,WAAX","names":["useFlowerBI","fetch","query","dependencies","queryJson","state","setState","records","result","setResult","disposed","length","some","x","dependency","filter","nonEmpty","then","select","calculations","exports"],"sources":["/Users/alex/Documents/Build/test/flowerbi/client/packages/flowerbi-react/src/useFlowerBI.ts"],"sourcesContent":["import { useState, useEffect } from \"react\";\nimport { Query, QueryFetch, jsonifyQuery, QueryResultJson, QuerySelect, expandQueryResult, ExpandedQueryResult, QueryCalculations } from \"flowerbi\";\nimport stableStringify from \"json-stable-stringify\";\n\nexport type UseQueryState = \"init\" | \"ready\" | \"refresh\" | \"error\";\n\nexport interface UseQueryResult<S extends QuerySelect, C extends QueryCalculations<S>> extends ExpandedQueryResult<S, C> {\n    /**\n     * The state of the query operation:\n     *\n     * - `init` - no result has been downloaded yet\n     * - `ready` - result has been downloaded\n     * - `refresh` - a new result is being downloaded\n     * - `error` - most recent query attempt failed\n     */\n    state: UseQueryState;\n}\n\n/**\n * Defines another query on which our query depends - for example a\n * first query may return the top 10 vendors, and a subsequent query\n * may then use an `in` filter to get details about those 10 vendors.\n */\nexport type QueryDependency = {\n    /**\n     * The result of the query we depend on\n     */\n    dependency: UseQueryResult<QuerySelect, QueryCalculations<QuerySelect>>;\n    /**\n     * If true (default is false) then if the dependency query produces\n     * an empty result, our query should also produce an empty result,\n     * so there is no need to execute it.\n     */\n    nonEmpty?: boolean;\n};\n\n/**\n * A custom React hook that evaluates to the result of a\n * [Query](../flowerbi/interfaces/query.html), making it easy to perform a\n * query from within a component.\n *\n * The returned object has a strongly-typed `records` array, and optionally\n * a `totals` object. It has a `state` of type {@link UseQueryState} that\n * can be used to show a loading indicator.\n *\n * @param fetch The fetch function to use.\n * @param query The [Query](../flowerbi/interfaces/query.html) specification.\n * @param dependencies Optionally, a list of one or more other queries whose\n * results are used to build this query, so we wait for them before executing,\n * and optionally short-circuit to an empty result if the dependency is empty.\n */\nexport function useFlowerBI<S extends QuerySelect, C extends QueryCalculations<S>>(\n    fetch: QueryFetch,\n    query: Query<S, C>,\n    dependencies?: QueryDependency[]\n): UseQueryResult<S, C> {\n    const queryJson = jsonifyQuery(query);\n\n    const [state, setState] = useState<UseQueryState>(\"init\");\n    const [result, setResult] = useState<QueryResultJson>({ records: [] });\n\n    useEffect(() => {\n        let disposed = false; // discard stale results\n\n        if (dependencies?.length) {\n            // if any not ready, neither are we\n            if (dependencies.some((x) => x.dependency.state !== \"ready\")) {\n                if (state !== \"init\") {\n                    setState(\"refresh\");\n                }\n                return;\n            }\n\n            // if any with option nonEmpty produced empty result, so do we\n            if (dependencies.filter((x) => !!x.nonEmpty).some((x) => !x.dependency.records.length)) {\n                setState(\"ready\");\n                setResult({ records: [] });\n                return;\n            }\n        }\n\n        if (state !== \"init\") {\n            setState(\"refresh\");\n        }\n\n        fetch(queryJson).then(\n            (x) => {\n                if (!disposed) {\n                    setState(\"ready\");\n                    setResult(x);\n                }\n            },\n            () => {\n                if (!disposed) {\n                    setState(\"error\");\n                }\n            }\n        );\n\n        return () => {\n            disposed = true;\n        };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [fetch, stableStringify(queryJson)]);\n\n    return { ...expandQueryResult<S, C>(query.select, result, query.calculations), state };\n}\n\n/**\n * Alias of useFlowerBI for backward compatibility.\n */\nexport const useQuery = useFlowerBI;\n"]},"metadata":{},"sourceType":"script"}