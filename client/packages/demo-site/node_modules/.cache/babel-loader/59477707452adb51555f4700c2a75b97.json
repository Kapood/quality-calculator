{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StringQueryColumn = exports.IntegerQueryColumn = exports.NumericQueryColumn = exports.QueryColumn = void 0;\n/**\n * A column from the schema, with a name and a data type. A whole schema of\n * such declared columns can be auto-generated using the CLI.\n */\n\nvar QueryColumn =\n/** @class */\nfunction () {\n  /**\n   * @param name The name, of the form `table.column`.\n   */\n  function QueryColumn(name) {\n    this.name = name;\n  }\n\n  QueryColumn.prototype.aggregation = function (aggregationType, filters) {\n    return {\n      column: this.name,\n      function: aggregationType,\n      filters: filters\n    };\n  };\n  /**\n   * Aggregates the column by counting values.\n   * @param filters Optional filters to apply.\n   */\n\n\n  QueryColumn.prototype.count = function (filters) {\n    return this.aggregation(\"Count\", filters);\n  };\n  /**\n   * Aggregates the column by counting distinct values.\n   * @param filters Optional filters to apply.\n   */\n\n\n  QueryColumn.prototype.countDistinct = function (filters) {\n    return this.aggregation(\"CountDistinct\", filters);\n  };\n  /**\n   * Aggregates the column by selecting the minimum value.\n   * @param filters Optional filters to apply.\n   */\n\n\n  QueryColumn.prototype.min = function (filters) {\n    return this.aggregation(\"Min\", filters);\n  };\n  /**\n   * Aggregates the column by selecting the maximum value.\n   * @param filters Optional filters to apply.\n   */\n\n\n  QueryColumn.prototype.max = function (filters) {\n    return this.aggregation(\"Max\", filters);\n  };\n\n  QueryColumn.prototype.filter = function (operator, value) {\n    return {\n      column: this.name,\n      operator: operator,\n      value: value\n    };\n  };\n  /**\n   * Sorts by the column in ascending order.\n   */\n\n\n  QueryColumn.prototype.ascending = function () {\n    return {\n      column: this.name,\n      descending: false\n    };\n  };\n  /**\n   * Sorts by the column in descending order.\n   */\n\n\n  QueryColumn.prototype.descending = function () {\n    return {\n      column: this.name,\n      descending: true\n    };\n  };\n  /**\n   * Produces a filter that requires this column to be equal to some value.\n   */\n\n\n  QueryColumn.prototype.equalTo = function (value) {\n    return this.filter(\"=\", value);\n  };\n  /**\n   * Produces a filter that requires this column to be not equal to some value.\n   */\n\n\n  QueryColumn.prototype.notEqualTo = function (value) {\n    return this.filter(\"<>\", value);\n  };\n  /**\n   * Produces a filter that requires this column to be greater than to some\n   * value.\n   */\n\n\n  QueryColumn.prototype.greaterThan = function (value) {\n    return this.filter(\">\", value);\n  };\n  /**\n   * Produces a filter that requires this column to be less than to some value.\n   */\n\n\n  QueryColumn.prototype.lessThan = function (value) {\n    return this.filter(\"<\", value);\n  };\n  /**\n   * Produces a filter that requires this column to be greater than or equal to\n   * some value.\n   */\n\n\n  QueryColumn.prototype.greaterThanOrEqualTo = function (value) {\n    return this.filter(\">=\", value);\n  };\n  /**\n   * Produces a filter that requires this column to be less than or equal to\n   * some value.\n   */\n\n\n  QueryColumn.prototype.lessThanOrEqualTo = function (value) {\n    return this.filter(\"<=\", value);\n  };\n  /**\n   * Produces a filter that requires this column's value to appear in the list.\n   * Only supported for number or string columns.\n   */\n\n\n  QueryColumn.prototype.in = function (value) {\n    return {\n      column: this.name,\n      operator: \"IN\",\n      value: value\n    };\n  };\n  /**\n   * Produces a filter that requires this column's value to not appear in the list.\n   * Only supported for number or string columns.\n   */\n\n\n  QueryColumn.prototype.notIn = function (value) {\n    return {\n      column: this.name,\n      operator: \"NOT IN\",\n      value: value\n    };\n  };\n\n  return QueryColumn;\n}();\n\nexports.QueryColumn = QueryColumn;\n\nvar NumericQueryColumn =\n/** @class */\nfunction (_super) {\n  __extends(NumericQueryColumn, _super);\n  /**\n   * @param name The name, of the form `table.column`.\n   */\n\n\n  function NumericQueryColumn(name) {\n    var _this = _super.call(this, name) || this;\n\n    _this.name = name;\n    return _this;\n  }\n  /**\n   * Aggregates the column by summing values.\n   * @param filters Optional filters to apply.\n   */\n\n\n  NumericQueryColumn.prototype.sum = function (filters) {\n    return this.aggregation(\"Sum\", filters);\n  };\n  /**\n   * Aggregates the column by averaging values.\n   * @param filters Optional filters to apply.\n   */\n\n\n  NumericQueryColumn.prototype.avg = function (filters) {\n    return this.aggregation(\"Avg\", filters);\n  };\n\n  return NumericQueryColumn;\n}(QueryColumn);\n\nexports.NumericQueryColumn = NumericQueryColumn;\n\nvar IntegerQueryColumn =\n/** @class */\nfunction (_super) {\n  __extends(IntegerQueryColumn, _super);\n  /**\n   * @param name The name, of the form `table.column`.\n   */\n\n\n  function IntegerQueryColumn(name) {\n    var _this = _super.call(this, name) || this;\n\n    _this.name = name;\n    return _this;\n  }\n\n  IntegerQueryColumn.prototype.bitsIn = function (mask, value) {\n    return {\n      column: this.name,\n      operator: \"BITS IN\",\n      constant: mask,\n      value: value\n    };\n  };\n\n  return IntegerQueryColumn;\n}(NumericQueryColumn);\n\nexports.IntegerQueryColumn = IntegerQueryColumn;\n\nvar StringQueryColumn =\n/** @class */\nfunction (_super) {\n  __extends(StringQueryColumn, _super);\n  /**\n   * @param name The name, of the form `table.column`.\n   */\n\n\n  function StringQueryColumn(name) {\n    var _this = _super.call(this, name) || this;\n\n    _this.name = name;\n    return _this;\n  }\n  /**\n   * Produces a filter that requires this column to match a LIKE expression.\n   */\n\n\n  StringQueryColumn.prototype.like = function (value) {\n    return this.filter(\"LIKE\", value);\n  };\n\n  return StringQueryColumn;\n}(QueryColumn);\n\nexports.StringQueryColumn = StringQueryColumn;","map":{"version":3,"mappings":"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","names":["name","QueryColumn","aggregationType","filters","column","function","aggregation","operator","value","descending","filter","exports","__extends","_super","_this","NumericQueryColumn","IntegerQueryColumn","mask","constant","StringQueryColumn"],"sources":["/Users/alex/Documents/Build/test/flowerbi/client/packages/flowerbi/src/QueryColumn.ts"],"sourcesContent":["import { FilterValue, AggregationType, FilterJson, AggregationJson, FilterOperator, OrderingJson } from \"./QueryJson\";\n\n/**\n * A column from the schema, with a name and a data type. A whole schema of\n * such declared columns can be auto-generated using the CLI.\n */\nexport class QueryColumn<T extends FilterValue> {\n    /**\n     * @param name The name, of the form `table.column`.\n     */\n    constructor(public readonly name: string) {}\n\n    protected aggregation(aggregationType: AggregationType, filters?: FilterJson[]): AggregationJson {\n        return {\n            column: this.name,\n            function: aggregationType,\n            filters,\n        };\n    }\n\n    /**\n     * Aggregates the column by counting values.\n     * @param filters Optional filters to apply.\n     */\n    count(filters?: FilterJson[]) {\n        return this.aggregation(\"Count\", filters);\n    }\n\n    /**\n     * Aggregates the column by counting distinct values.\n     * @param filters Optional filters to apply.\n     */\n    countDistinct(filters?: FilterJson[]) {\n        return this.aggregation(\"CountDistinct\", filters);\n    }\n\n    /**\n     * Aggregates the column by selecting the minimum value.\n     * @param filters Optional filters to apply.\n     */\n    min(filters?: FilterJson[]) {\n        return this.aggregation(\"Min\", filters);\n    }\n\n    /**\n     * Aggregates the column by selecting the maximum value.\n     * @param filters Optional filters to apply.\n     */\n    max(filters?: FilterJson[]) {\n        return this.aggregation(\"Max\", filters);\n    }\n\n    protected filter(operator: FilterOperator, value: T): FilterJson {\n        return {\n            column: this.name,\n            operator,\n            value,\n        };\n    }\n\n    /**\n     * Sorts by the column in ascending order.\n     */\n    ascending(): OrderingJson {\n        return { column: this.name, descending: false };\n    }\n\n    /**\n     * Sorts by the column in descending order.\n     */\n    descending(): OrderingJson {\n        return { column: this.name, descending: true };\n    }\n\n    /**\n     * Produces a filter that requires this column to be equal to some value.\n     */\n    equalTo(value: T) {\n        return this.filter(\"=\", value);\n    }\n\n    /**\n     * Produces a filter that requires this column to be not equal to some value.\n     */\n    notEqualTo(value: T) {\n        return this.filter(\"<>\", value);\n    }\n\n    /**\n     * Produces a filter that requires this column to be greater than to some\n     * value.\n     */\n    greaterThan(value: T) {\n        return this.filter(\">\", value);\n    }\n\n    /**\n     * Produces a filter that requires this column to be less than to some value.\n     */\n    lessThan(value: T) {\n        return this.filter(\"<\", value);\n    }\n\n    /**\n     * Produces a filter that requires this column to be greater than or equal to\n     * some value.\n     */\n    greaterThanOrEqualTo(value: T) {\n        return this.filter(\">=\", value);\n    }\n\n    /**\n     * Produces a filter that requires this column to be less than or equal to\n     * some value.\n     */\n    lessThanOrEqualTo(value: T) {\n        return this.filter(\"<=\", value);\n    }\n\n    /**\n     * Produces a filter that requires this column's value to appear in the list.\n     * Only supported for number or string columns.\n     */\n    in(value: T extends number | string ? T[] : never): FilterJson {\n        return {\n            column: this.name,\n            operator: \"IN\",\n            value,\n        };\n    }\n\n    /**\n     * Produces a filter that requires this column's value to not appear in the list.\n     * Only supported for number or string columns.\n     */\n    notIn(value: T extends number | string ? T[] : never): FilterJson {\n        return {\n            column: this.name,\n            operator: \"NOT IN\",\n            value,\n        };\n    }\n}\n\nexport class NumericQueryColumn<T extends number | null = number> extends QueryColumn<T> {\n    /**\n     * @param name The name, of the form `table.column`.\n     */\n    constructor(public readonly name: string) {\n        super(name);\n    }\n\n    /**\n     * Aggregates the column by summing values.\n     * @param filters Optional filters to apply.\n     */\n    sum(filters?: FilterJson[]) {\n        return this.aggregation(\"Sum\", filters);\n    }\n\n    /**\n     * Aggregates the column by averaging values.\n     * @param filters Optional filters to apply.\n     */\n    avg(filters?: FilterJson[]) {\n        return this.aggregation(\"Avg\", filters);\n    }\n}\n\nexport class IntegerQueryColumn<T extends number | null = number> extends NumericQueryColumn<T> {\n    /**\n     * @param name The name, of the form `table.column`.\n     */\n    constructor(public readonly name: string) {\n        super(name);\n    }\n\n    bitsIn(mask: number, value: NonNullable<T>[]): FilterJson {\n        return {\n            column: this.name,\n            operator: \"BITS IN\",\n            constant: mask,\n            value,\n        };\n    }\n}\n\nexport class StringQueryColumn<T extends string | null = string> extends QueryColumn<T> {\n    /**\n     * @param name The name, of the form `table.column`.\n     */\n    constructor(public readonly name: string) {\n        super(name);\n    }\n\n    /**\n     * Produces a filter that requires this column to match a LIKE expression.\n     */\n    like(value: T) {\n        return this.filter(\"LIKE\", value);\n    }\n}\n"]},"metadata":{},"sourceType":"script"}