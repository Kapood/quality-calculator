{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.executeQuery = exports.expandQueryResult = exports.getAggregateValuesOnly = exports.expandQueryRecord = exports.jsonifyQuery = void 0;\n\nvar queryModel_1 = require(\"./queryModel\");\n\nvar arrayHelpers_1 = require(\"./arrayHelpers\");\n\nfunction jsonifyCalculation(calculation, props) {\n  if (typeof calculation === \"string\") {\n    var aggregation = props.indexOf(calculation);\n\n    if (aggregation === -1) {\n      throw new Error(\"Not a valid aggregation name: \".concat(calculation));\n    }\n\n    return {\n      aggregation: aggregation\n    };\n  }\n\n  if (typeof calculation === \"number\") {\n    return {\n      value: calculation\n    };\n  }\n\n  if (calculation instanceof Array) {\n    return {\n      first: jsonifyCalculation(calculation[0], props),\n      operator: calculation[1],\n      second: jsonifyCalculation(calculation[2], props)\n    };\n  }\n\n  throw new Error(\"Invalid calculation\");\n}\n\nfunction jsonifyOrdering(ordering, selects, values, calculations) {\n  if (\"select\" in ordering) {\n    var index = selects.indexOf(ordering.select);\n\n    if (index !== -1) {\n      return {\n        type: \"Select\",\n        index: index,\n        descending: ordering.descending\n      };\n    }\n\n    index = values.indexOf(ordering.select);\n\n    if (index !== -1) {\n      return {\n        type: \"Value\",\n        index: index,\n        descending: ordering.descending\n      };\n    }\n\n    throw new Error(\"Invalid ordering select key: \".concat(String(ordering.select)));\n  }\n\n  if (\"calculation\" in ordering) {\n    var index = calculations.indexOf(ordering.calculation);\n\n    if (index !== -1) {\n      return {\n        type: \"Calculation\",\n        index: index,\n        descending: ordering.descending\n      };\n    }\n\n    throw new Error(\"Invalid ordering calculation key: \".concat(String(ordering.calculation)));\n  }\n\n  return ordering;\n}\n/**\n * Converts a statically-typed {@link Query} into the {@link QueryJson}\n * format, ready to be sent to your API.\n * @param query\n */\n\n\nfunction jsonifyQuery(query) {\n  var _a;\n\n  var select = query.select,\n      filters = query.filters,\n      calculations = query.calculations,\n      orderBy = query.orderBy,\n      totals = query.totals,\n      take = query.take,\n      skip = query.skip,\n      comment = query.comment,\n      allowDuplicates = query.allowDuplicates,\n      fullJoins = query.fullJoins;\n  var columnProps = (0, queryModel_1.getColumnPropsOnly)(select);\n  var aggregationProps = (0, queryModel_1.getAggregatePropsOnly)(select);\n  var calculationProps = calculations ? (0, arrayHelpers_1.keysOf)(calculations) : [];\n  return {\n    select: columnProps.map(function (key) {\n      return select[key].name;\n    }),\n    aggregations: aggregationProps.map(function (key) {\n      return select[key];\n    }),\n    calculations: calculations ? calculationProps.map(function (key) {\n      return jsonifyCalculation(calculations[key], aggregationProps);\n    }) : undefined,\n    filters: filters !== null && filters !== void 0 ? filters : [],\n    orderBy: (_a = orderBy === null || orderBy === void 0 ? void 0 : orderBy.map(function (o) {\n      return jsonifyOrdering(o, columnProps, aggregationProps, calculationProps);\n    })) !== null && _a !== void 0 ? _a : [],\n    totals: totals !== null && totals !== void 0 ? totals : false,\n    skip: skip !== null && skip !== void 0 ? skip : 0,\n    take: take !== null && take !== void 0 ? take : 100,\n    comment: comment,\n    allowDuplicates: allowDuplicates,\n    fullJoins: fullJoins\n  };\n}\n\nexports.jsonifyQuery = jsonifyQuery;\n/**\n * Converts the `QueryRecordJson` for a single record into a strongly-typed record\n * with named properties, using the {@link Query.select} from the query to perform\n * the necessary mapping.\n * @param select The {@link Query.select} property from the query.\n * @param record The record returned from your API.\n */\n\nfunction expandQueryRecord(select, record, calcs) {\n  var result = {};\n  var n = 0;\n\n  for (var _i = 0, _a = (0, queryModel_1.getAggregatePropsOnly)(select); _i < _a.length; _i++) {\n    var key = _a[_i];\n    result[key] = record.aggregated[n++];\n  }\n\n  var calculationProps = calcs ? (0, arrayHelpers_1.keysOf)(calcs) : [];\n\n  for (var _b = 0, calculationProps_1 = calculationProps; _b < calculationProps_1.length; _b++) {\n    var key = calculationProps_1[_b];\n    result[key] = record.aggregated[n++];\n  }\n\n  n = 0;\n\n  for (var _c = 0, _d = (0, queryModel_1.getColumnPropsOnly)(select); _c < _d.length; _c++) {\n    var key = _d[_c];\n    result[key] = record.selected[n++];\n  }\n\n  return result;\n}\n\nexports.expandQueryRecord = expandQueryRecord;\n/**\n * Converts the `QueryRecordJson` from the `totals` record into a strongly-typed\n * record named properties for the aggregated values only, using the\n * {@link Query.select} from the query to perform the necessary mapping.\n *\n * @param select The {@link Query.select} property from the query.\n * @param record The {@link QueryResultJson.totals} record returned from your API.\n */\n\nfunction getAggregateValuesOnly(select, record, calcs) {\n  var result = {};\n  var n = 0;\n\n  for (var _i = 0, _a = (0, queryModel_1.getAggregatePropsOnly)(select); _i < _a.length; _i++) {\n    var key = _a[_i];\n    result[key] = record.aggregated[n++];\n  }\n\n  var calculationProps = calcs ? (0, arrayHelpers_1.keysOf)(calcs) : [];\n\n  for (var _b = 0, calculationProps_2 = calculationProps; _b < calculationProps_2.length; _b++) {\n    var key = calculationProps_2[_b];\n    result[key] = record.aggregated[n++];\n  }\n\n  return result;\n}\n\nexports.getAggregateValuesOnly = getAggregateValuesOnly;\n/**\n * Converts the payload returned from the API into the statically-typed\n * form appropriate for the query.\n * @param select The {@link Query.select} property from the query.\n * @param result The response payload from the API call.\n */\n\nfunction expandQueryResult(select, result, calcs) {\n  return {\n    records: result.records.map(function (r) {\n      return expandQueryRecord(select, r, calcs);\n    }),\n    totals: result.totals && getAggregateValuesOnly(select, result.totals, calcs)\n  };\n}\n\nexports.expandQueryResult = expandQueryResult;\n/**\n * The complete statically typed query mechanism.\n *\n * @param fetch Your API for performing FlowerBI queries in the JSON format\n * @param query The query in statically-typed form\n * @returns The query results in statically-typed form\n */\n\nfunction executeQuery(fetch, query) {\n  return __awaiter(this, void 0, void 0, function () {\n    var queryJson, resultJson;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          queryJson = jsonifyQuery(query);\n          return [4\n          /*yield*/\n          , fetch(queryJson)];\n\n        case 1:\n          resultJson = _a.sent();\n          return [2\n          /*return*/\n          , expandQueryResult(query.select, resultJson, query.calculations)];\n      }\n    });\n  });\n}\n\nexports.executeQuery = executeQuery;","map":{"version":3,"mappings":"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","names":["jsonifyCalculation","calculation","props","aggregation","indexOf","Error","value","Array","first","operator","second","jsonifyOrdering","ordering","selects","values","calculations","index","select","type","descending","String","jsonifyQuery","query","filters","orderBy","totals","take","skip","comment","allowDuplicates","fullJoins","columnProps","aggregationProps","calculationProps","map","key","name","aggregations","undefined","o","_a","exports","expandQueryRecord","record","calcs","result","n","_i","aggregated","_b","_c","selected","getAggregateValuesOnly","expandQueryResult","records","r","executeQuery","fetch","queryJson","resultJson"],"sources":["/Users/alex/Documents/Build/test/flowerbi/client/packages/flowerbi/src/executeQuery.ts"],"sourcesContent":["import {\n    Query,\n    QuerySelect,\n    ExpandedQueryRecord,\n    AggregateValuesOnly,\n    getAggregatePropsOnly,\n    getColumnPropsOnly,\n    Calculation,\n    AggregatePropsOnly,\n    QueryCalculations,\n    Ordering,\n    CalculationValues,\n} from \"./queryModel\";\nimport { QueryJson, AggregationJson, CalculationJson, OrderingJson } from \"./QueryJson\";\nimport { QueryColumn } from \"./QueryColumn\";\nimport { keysOf } from \"./arrayHelpers\";\n\n/**\n * The allowed data types for plain columns.\n */\nexport type QuerySelectValue = number | string | Date | boolean;\n\n/**\n * The JSON format of a record returned from the API when executing a query.\n */\nexport interface QueryRecordJson {\n    /**\n     * The plain column values.\n     */\n    selected: QuerySelectValue[];\n    /**\n     * The aggregated column values.\n     */\n    aggregated: number[];\n}\n\n/**\n * The JSON format of the whole payload returned from the API when\n * executing a query.\n */\nexport interface QueryResultJson {\n    /**\n     * The records of the query result.\n     */\n    records: QueryRecordJson[];\n\n    /**\n     * Optional extra record, only available if {@link QueryJson.totals}\n     * was specified as `true` in the query, containing the aggregation\n     * totals.\n     */\n    totals?: QueryRecordJson;\n}\n\n/**\n * The function you need to implement to pass {@link QueryJson} payloads to\n * your API and get them executed. This will typically be a wrapper around\n * the `fetch` browser API, or something more high-level, and can make use\n * of whatever authentication method you prefer.\n */\nexport type QueryFetch = (queryJson: QueryJson) => Promise<QueryResultJson>;\n\nfunction jsonifyCalculation<S extends QuerySelect>(calculation: Calculation<S>, props: AggregatePropsOnly<S>[]): CalculationJson {\n    if (typeof calculation === \"string\") {\n        const aggregation = props.indexOf(calculation);\n        if (aggregation === -1) {\n            throw new Error(`Not a valid aggregation name: ${calculation}`);\n        }\n        return { aggregation };\n    }\n    if (typeof calculation === \"number\") {\n        return {\n            value: calculation,\n        };\n    }\n    if (calculation instanceof Array) {\n        return {\n            first: jsonifyCalculation(calculation[0], props),\n            operator: calculation[1],\n            second: jsonifyCalculation(calculation[2], props),\n        };\n    }\n    throw new Error(\"Invalid calculation\");\n}\n\nfunction jsonifyOrdering<S extends QuerySelect, C extends QueryCalculations<S>>(\n    ordering: OrderingJson | Ordering<S, C>,\n    selects: string[],\n    values: string[],\n    calculations: string[]\n): OrderingJson {\n    if (\"select\" in ordering) {\n        let index = selects.indexOf(ordering.select as string);\n        if (index !== -1) {\n            return {\n                type: \"Select\",\n                index,\n                descending: ordering.descending,\n            };\n        }\n        index = values.indexOf(ordering.select as string);\n        if (index !== -1) {\n            return {\n                type: \"Value\",\n                index,\n                descending: ordering.descending,\n            };\n        }\n        throw new Error(`Invalid ordering select key: ${String(ordering.select)}`);\n    }\n    if (\"calculation\" in ordering) {\n        let index = calculations.indexOf(ordering.calculation as string);\n        if (index !== -1) {\n            return {\n                type: \"Calculation\",\n                index,\n                descending: ordering.descending,\n            };\n        }\n        throw new Error(`Invalid ordering calculation key: ${String(ordering.calculation)}`);\n    }\n    return ordering;\n}\n\n/**\n * Converts a statically-typed {@link Query} into the {@link QueryJson}\n * format, ready to be sent to your API.\n * @param query\n */\nexport function jsonifyQuery<S extends QuerySelect, C extends QueryCalculations<S>>(query: Query<S, C>): QueryJson {\n    const { select, filters, calculations, orderBy, totals, take, skip, comment, allowDuplicates, fullJoins } = query;\n\n    const columnProps = getColumnPropsOnly(select);\n    const aggregationProps = getAggregatePropsOnly(select);\n    const calculationProps = calculations ? keysOf(calculations) : [];\n\n    return {\n        select: columnProps.map((key) => (select[key] as QueryColumn<never>).name),\n        aggregations: aggregationProps.map((key) => select[key] as AggregationJson),\n        calculations: calculations ? calculationProps.map((key) => jsonifyCalculation(calculations[key] as Calculation<S>, aggregationProps)) : undefined,\n        filters: filters ?? [],\n        orderBy: orderBy?.map((o) => jsonifyOrdering(o, columnProps as string[], aggregationProps as string[], calculationProps as string[])) ?? [],\n        totals: totals ?? false,\n        skip: skip ?? 0,\n        take: take ?? 100,\n        comment,\n        allowDuplicates,\n        fullJoins,\n    };\n}\n\n/**\n * Converts the `QueryRecordJson` for a single record into a strongly-typed record\n * with named properties, using the {@link Query.select} from the query to perform\n * the necessary mapping.\n * @param select The {@link Query.select} property from the query.\n * @param record The record returned from your API.\n */\nexport function expandQueryRecord<S extends QuerySelect, C extends QueryCalculations<S>>(\n    select: S,\n    record: QueryRecordJson,\n    calcs?: C\n): ExpandedQueryRecord<S, C> {\n    const result: any = {};\n\n    let n = 0;\n    for (const key of getAggregatePropsOnly(select)) {\n        result[key] = record.aggregated[n++];\n    }\n\n    const calculationProps = calcs ? keysOf(calcs) : [];\n    for (const key of calculationProps) {\n        result[key] = record.aggregated[n++];\n    }\n\n    n = 0;\n    for (const key of getColumnPropsOnly(select)) {\n        result[key] = record.selected[n++];\n    }\n\n    return result;\n}\n\n/**\n * Converts the `QueryRecordJson` from the `totals` record into a strongly-typed\n * record named properties for the aggregated values only, using the\n * {@link Query.select} from the query to perform the necessary mapping.\n *\n * @param select The {@link Query.select} property from the query.\n * @param record The {@link QueryResultJson.totals} record returned from your API.\n */\nexport function getAggregateValuesOnly<S extends QuerySelect, C extends QueryCalculations<S>>(\n    select: S,\n    record: QueryRecordJson,\n    calcs?: C\n): AggregateValuesOnly<S> & CalculationValues<C> {\n    const result: any = {};\n\n    let n = 0;\n    for (const key of getAggregatePropsOnly(select)) {\n        result[key] = record.aggregated[n++];\n    }\n\n    const calculationProps = calcs ? keysOf(calcs) : [];\n    for (const key of calculationProps) {\n        result[key] = record.aggregated[n++];\n    }\n\n    return result;\n}\n\n/**\n * The statically-typed result of a {@link Query}.\n */\nexport interface ExpandedQueryResult<S extends QuerySelect, C extends QueryCalculations<S>> {\n    /**\n     * The set of records returned, each having named properties\n     * corresponding to the plain and aggregated columns selected\n     * in the query.\n     */\n    records: ExpandedQueryRecord<S, C>[];\n    /**\n     * Optional extra record, only available if {@link QueryJson.totals}\n     * was specified as `true` in the query, containing the aggregation\n     * totals.\n     */\n    totals?: AggregateValuesOnly<S> & CalculationValues<C>;\n}\n\n/**\n * Converts the payload returned from the API into the statically-typed\n * form appropriate for the query.\n * @param select The {@link Query.select} property from the query.\n * @param result The response payload from the API call.\n */\nexport function expandQueryResult<S extends QuerySelect, C extends QueryCalculations<S>>(\n    select: S,\n    result: QueryResultJson,\n    calcs?: C\n): ExpandedQueryResult<S, C> {\n    return {\n        records: result.records.map((r) => expandQueryRecord(select, r, calcs)),\n        totals: result.totals && getAggregateValuesOnly(select, result.totals, calcs),\n    };\n}\n\n/**\n * The complete statically typed query mechanism.\n * \n * @param fetch Your API for performing FlowerBI queries in the JSON format\n * @param query The query in statically-typed form\n * @returns The query results in statically-typed form\n */\nexport async function executeQuery<S extends QuerySelect, C extends QueryCalculations<S>>(fetch: QueryFetch, query: Query<S, C>) {\n    const queryJson = jsonifyQuery(query);\n    const resultJson = await fetch(queryJson);\n    return expandQueryResult<S, C>(query.select, resultJson, query.calculations);\n}\n"]},"metadata":{},"sourceType":"script"}