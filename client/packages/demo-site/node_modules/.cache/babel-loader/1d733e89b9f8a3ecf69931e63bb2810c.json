{"ast":null,"code":"var _jsxFileName = \"/Users/alex/Documents/Build/test/flowerbi/client/packages/demo-site/src/Reports/TypesOfError.tsx\",\n    _s = $RefreshSig$();\n\nimport React, { useRef } from \"react\";\nimport { distinct, keysOf } from \"flowerbi\";\nimport { useQuery } from \"flowerbi-react\";\nimport { FlowerBIChartBox } from \"flowerbi-react-utils\";\nimport { Bug, Workflow, CategoryCombination } from \"../demoSchema\";\nimport { dataColours } from \"./dataColours\";\nimport { Bar } from \"react-chartjs-2\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst categoriesRaw = {\n  \"Crashed\": CategoryCombination.Crashed,\n  \"Data loss\": CategoryCombination.DataLoss,\n  \"Security breach\": CategoryCombination.SecurityBreach,\n  \"Off by one\": CategoryCombination.OffByOne,\n  \"Slow\": CategoryCombination.Slow,\n  \"Stack overflow\": CategoryCombination.StackOverflow\n};\nconst categories = categoriesRaw;\nexport function TypesOfError(_ref) {\n  _s();\n\n  let {\n    pageFilters,\n    fetch\n  } = _ref;\n  const id = \"TypesOfError\"; // In the query we ask for the bits describing the categories applicable to each bug\n\n  const query = {\n    select: {\n      categoryBits: Bug.CategoryCombinationId,\n      workflowState: Workflow.WorkflowState,\n      bugCount: Bug.Id.count()\n    },\n    filters: [Workflow.Resolved.equalTo(true), ...pageFilters.getFilters(id)]\n  };\n  const data = useQuery(fetch, query);\n  const chart = useRef(null);\n  const distinctWorkflowStates = distinct(data.records.map(r => r.workflowState)); // Convert the bit combinations into category labels\n\n  const bugCountByStateAndCategory = distinctWorkflowStates.flatMap(workflowState => keysOf(categories).map((category, bit) => ({\n    workflowState,\n    category,\n    bugCount: data.records.filter(r => r.workflowState === workflowState && r.categoryBits & 1 << bit).map(r => r.bugCount).reduce((l, r) => l + r, 0)\n  }))); // Sum up the categories (full height of each bar)\n\n  const bugCountByCategory = keysOf(categories).map(category => ({\n    category,\n    bugCount: bugCountByStateAndCategory.filter(r => r.category === category).map(r => r.bugCount).reduce((l, r) => l + r, 0)\n  })); // Sort by bugCount descending so tallest bar is first\n\n  bugCountByCategory.sort((x, y) => y.bugCount - x.bugCount); // Omit empty categories\n\n  const orderedCategories = bugCountByCategory.filter(c => c.bugCount > 0).map(c => c.category);\n  return /*#__PURE__*/_jsxDEV(FlowerBIChartBox, {\n    id: id,\n    title: \"Project Quality Metrics\",\n    state: data.state,\n    children: /*#__PURE__*/_jsxDEV(Bar, {\n      ref: chart,\n      options: {\n        scales: {\n          x: {\n            stacked: true\n          },\n          y: {\n            stacked: true,\n            beginAtZero: true\n          }\n        },\n\n        onClick(evt, elements, chart) {\n          console.log(\"clicked\", {\n            evt,\n            elements,\n            chart\n          });\n\n          if (elements[0]) {\n            const category = orderedCategories[elements[0].index];\n            const workflowState = distinctWorkflowStates[elements[0].datasetIndex];\n            console.log(\"Category:\", category, \"WorkflowState:\", workflowState);\n            pageFilters.setInteraction(id, [Workflow.WorkflowState.equalTo(workflowState), categories[category].equalTo(true)]);\n          }\n        }\n\n      },\n      data: {\n        labels: orderedCategories,\n        datasets: distinctWorkflowStates.map((workflowState, colour) => ({\n          label: workflowState,\n          data: orderedCategories.map(category => {\n            var _bugCountByStateAndCa, _bugCountByStateAndCa2;\n\n            return (_bugCountByStateAndCa = (_bugCountByStateAndCa2 = bugCountByStateAndCategory.find(r => r.workflowState === workflowState && r.category === category)) === null || _bugCountByStateAndCa2 === void 0 ? void 0 : _bugCountByStateAndCa2.bugCount) !== null && _bugCountByStateAndCa !== void 0 ? _bugCountByStateAndCa : 0;\n          }),\n          backgroundColor: dataColours[colour]\n        }))\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 75,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 74,\n    columnNumber: 9\n  }, this);\n}\n\n_s(TypesOfError, \"HdDA2/mABpUf0zxpwuU6I8NXJZU=\", false, function () {\n  return [useQuery];\n});\n\n_c = TypesOfError;\n\nvar _c;\n\n$RefreshReg$(_c, \"TypesOfError\");","map":{"version":3,"sources":["/Users/alex/Documents/Build/test/flowerbi/client/packages/demo-site/src/Reports/TypesOfError.tsx"],"names":["React","useRef","distinct","keysOf","useQuery","FlowerBIChartBox","Bug","Workflow","CategoryCombination","dataColours","Bar","categoriesRaw","Crashed","DataLoss","SecurityBreach","OffByOne","Slow","StackOverflow","categories","TypesOfError","pageFilters","fetch","id","query","select","categoryBits","CategoryCombinationId","workflowState","WorkflowState","bugCount","Id","count","filters","Resolved","equalTo","getFilters","data","chart","distinctWorkflowStates","records","map","r","bugCountByStateAndCategory","flatMap","category","bit","filter","reduce","l","bugCountByCategory","sort","x","y","orderedCategories","c","state","scales","stacked","beginAtZero","onClick","evt","elements","console","log","index","datasetIndex","setInteraction","labels","datasets","colour","label","find","backgroundColor"],"mappings":"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","sourcesContent":["import React, { useRef } from \"react\";\nimport { QueryColumn, distinct, keysOf } from \"flowerbi\";\nimport { useQuery } from \"flowerbi-react\";\nimport { FlowerBIChartBox } from \"flowerbi-react-utils\";\nimport { Bug, Workflow, CategoryCombination } from \"../demoSchema\";\nimport { dataColours } from \"./dataColours\";\nimport { Bar } from \"react-chartjs-2\";\nimport { Chart as ChartJS } from \"chart.js\";\nimport { VisualProps } from \"./VisualProps\";\n\nconst categoriesRaw = {\n    \"Crashed\": CategoryCombination.Crashed,\n    \"Data loss\": CategoryCombination.DataLoss,\n    \"Security breach\": CategoryCombination.SecurityBreach,\n    \"Off by one\": CategoryCombination.OffByOne,\n    \"Slow\": CategoryCombination.Slow,\n    \"Stack overflow\": CategoryCombination.StackOverflow,\n};\n\ntype CategoryLabel = keyof typeof categoriesRaw;\n\nconst categories: Record<CategoryLabel, QueryColumn<boolean>> = categoriesRaw;\n\nexport function TypesOfError({ pageFilters, fetch }: VisualProps) {\n\n    const id = \"TypesOfError\";\n\n    // In the query we ask for the bits describing the categories applicable to each bug\n    const query = {\n        select: {\n            categoryBits: Bug.CategoryCombinationId, \n            workflowState: Workflow.WorkflowState,\n            bugCount: Bug.Id.count()\n        },\n        filters: [\n            Workflow.Resolved.equalTo(true),\n            ...pageFilters.getFilters(id)\n        ]\n    };\n\n    const data = useQuery(fetch, query);\n\n    const chart = useRef<ChartJS<\"bar\">>(null);\n\n    const distinctWorkflowStates = distinct(data.records.map(r => r.workflowState));\n\n    // Convert the bit combinations into category labels\n    const bugCountByStateAndCategory = distinctWorkflowStates.flatMap(workflowState =>\n        keysOf(categories).map((category, bit) => ({\n            workflowState,\n            category,\n            bugCount: data.records\n                .filter(r => r.workflowState === workflowState && r.categoryBits & (1 << bit))\n                .map(r => r.bugCount)\n                .reduce((l, r) => l + r, 0)\n        })));\n\n    // Sum up the categories (full height of each bar)\n    const bugCountByCategory = keysOf(categories).map(category => ({\n        category,\n        bugCount: bugCountByStateAndCategory\n            .filter(r => r.category === category)\n            .map(r => r.bugCount)\n            .reduce((l, r) => l + r, 0)\n    }));\n\n    // Sort by bugCount descending so tallest bar is first\n    bugCountByCategory.sort((x, y) => y.bugCount - x.bugCount);\n\n    // Omit empty categories\n    const orderedCategories = bugCountByCategory.filter(c => c.bugCount > 0).map(c => c.category);\n\n    return (\n        <FlowerBIChartBox id={id} title=\"Project Quality Metrics\" state={data.state}>\n            <Bar \n                ref={chart}\n                options={{ \n                    scales: {\n                        x: { stacked: true },\n                        y: { stacked: true, beginAtZero: true}\n                    },\n                    onClick(evt, elements, chart) {\n                        console.log(\"clicked\", { evt, elements, chart });\n                        if (elements[0]) {\n\n                            const category = orderedCategories[elements[0].index];\n                            const workflowState = distinctWorkflowStates[elements[0].datasetIndex];\n\n                            console.log(\"Category:\", category, \"WorkflowState:\", workflowState);\n                            pageFilters.setInteraction(id, [                                \n                                 Workflow.WorkflowState.equalTo(workflowState), \n                                 categories[category].equalTo(true)                                \n                            ]);\n                        }\n                    }\n                }}\n                data={{\n                    labels: orderedCategories,\n                    datasets: distinctWorkflowStates.map((workflowState, colour) => ({\n                        label: workflowState,\n                        data: orderedCategories.map(category =>\n                            bugCountByStateAndCategory.find(r => r.workflowState === workflowState && \n                                                                 r.category === category)?.bugCount ?? 0),\n                        backgroundColor: dataColours[colour]\n                    }))\n                }}\n            />\n        </FlowerBIChartBox>\n    )\n}\n"]},"metadata":{},"sourceType":"module"}