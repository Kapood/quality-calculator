{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getColumnsOnly = exports.getColumnPropsOnly = exports.getAggregatePropsOnly = void 0;\n\nvar arrayHelpers_1 = require(\"./arrayHelpers\");\n\nvar QueryColumn_1 = require(\"./QueryColumn\");\n/**\n * Returns the names of properties in a query that refer to aggregated columns.\n * The result is an array of strings, but type-constrained to string literal types:\n *\n * ```ts\n * getAggregatePropsOnly({\n *    customer: Customer.Name,\n *    spend: Invoice.Amount.sum()\n * }) // [\"spend\"]\n * ```\n *\n * @param select the `select` object from a query\n */\n\n\nfunction getAggregatePropsOnly(select) {\n  var keys = (0, arrayHelpers_1.keysOf)(select).filter(function (x) {\n    return !(select[x] instanceof QueryColumn_1.QueryColumn);\n  });\n  return keys;\n}\n\nexports.getAggregatePropsOnly = getAggregatePropsOnly;\n/**\n * Returns the names of properties in a query that refer to plain columns. The\n * result is an array of strings, but type-constrained to string literal types:\n *\n * ```ts\n * getColumnPropsOnly({\n *    customer: Customer.Name,\n *    spend: Invoice.Amount.sum()\n * }) // [\"customer\"]\n * ```\n *\n * @param select the `select` object from a query\n */\n\nfunction getColumnPropsOnly(select) {\n  var keys = (0, arrayHelpers_1.keysOf)(select).filter(function (x) {\n    return select[x] instanceof QueryColumn_1.QueryColumn;\n  });\n  return keys;\n}\n\nexports.getColumnPropsOnly = getColumnPropsOnly;\n/**\n * Returns the plain column objects referred to in a query, ignoring\n * aggregated columns.\n * @param select the `select` object from a query\n */\n\nfunction getColumnsOnly(select) {\n  return (0, arrayHelpers_1.keysOf)(select).map(function (k) {\n    return select[k];\n  }).filter(function (x) {\n    return x instanceof QueryColumn_1.QueryColumn;\n  }).map(function (x) {\n    return x;\n  });\n}\n\nexports.getColumnsOnly = getColumnsOnly;","map":{"version":3,"mappings":";;;;;;;AAAA;;AACA;AAsDA;;;;;;;;;;;;;;;AAaA,SAAgBA,qBAAhB,CAA6DC,MAA7D,EAAsE;AAClE,MAAMC,IAAI,GAAG,2BAAOD,MAAP,EAAeE,MAAf,CAAsB,UAACC,CAAD,EAAE;AAAK,aAAEH,MAAM,CAACG,CAAD,CAAN,YAAqBC,yBAAvB;AAAmC,GAAhE,CAAb;AACA,SAAOH,IAAP;AACH;;AAHDI;AA+BA;;;;;;;;;;;;;;AAaA,SAAgBC,kBAAhB,CAA0DN,MAA1D,EAAmE;AAC/D,MAAMC,IAAI,GAAG,2BAAOD,MAAP,EAAeE,MAAf,CAAsB,UAACC,CAAD,EAAE;AAAK,iBAAM,CAACA,CAAD,CAAN,YAAqBC,yBAArB;AAAgC,GAA7D,CAAb;AACA,SAAOH,IAAP;AACH;;AAHDI;AAKA;;;;;;AAKA,SAAgBE,cAAhB,CAA+BP,MAA/B,EAAkD;AAC9C,SAAO,2BAAOA,MAAP,EACFQ,GADE,CACE,UAACC,CAAD,EAAE;AAAK,iBAAM,CAACA,CAAD,CAAN;AAAS,GADlB,EAEFP,MAFE,CAEK,UAACC,CAAD,EAAE;AAAK,YAAC,YAAYC,yBAAb;AAAwB,GAFpC,EAGFI,GAHE,CAGE,UAACL,CAAD,EAAE;AAAK;AAAqB,GAH9B,CAAP;AAIH;;AALDE","names":["getAggregatePropsOnly","select","keys","filter","x","QueryColumn_1","exports","getColumnPropsOnly","getColumnsOnly","map","k"],"sources":["/Users/alex/Documents/Build/test/flowerbi/client/packages/flowerbi/src/queryModel.ts"],"sourcesContent":["import { keysOf } from \"./arrayHelpers\";\nimport { QueryColumn } from \"./QueryColumn\";\nimport { AggregationJson, FilterJson, OrderingJson } from \"./QueryJson\";\n\n/**\n * Defines the kinds of member that can appear in the `select` object of a query.\n * Queries can select plain columns, or aggregation functions on columns.\n */\nexport type SelectMember = QueryColumn<any> | AggregationJson;\n\n/**\n * The `select` object of a query has named properties of type {@link SelectMember}.\n */\nexport type QuerySelect = Record<string, SelectMember>;\n\n/**\n * Extracts the data type from a column. So `QueryColumnType<QueryColumn<boolean>>` is `boolean`.\n */\nexport type QueryColumnType<T> = T extends QueryColumn<infer C> ? C : never;\n\n/**\n * Defines the shape of a record returned from a query, based on its `select` object.\n * Each selected property appears as a property in the record with the same name. For\n * plain columns the data type depends on the column definition, but for aggregations\n * and calculations the data type is always `number`.\n */\nexport type ExpandedQueryRecord<S extends QuerySelect, C extends QueryCalculations<S>> = {\n    [P in keyof S]: S[P] extends QueryColumn<any> ? QueryColumnType<S[P]> : number;\n} & {\n    [P in keyof C]: number;\n};\n\n/**\n * Similar to {@link ExpandedQueryRecord} but the plain columns are optional, so they\n * may be `undefined`. Aggregations/calculations are not optional.\n */\nexport type ExpandedQueryRecordWithOptionalColumns<S extends QuerySelect, C extends QueryCalculations<S>> = {\n    [P in keyof S]: S[P] extends QueryColumn<any> ? QueryColumnType<S[P]> | undefined : number;\n} & {\n    [P in keyof C]: number;\n};\n\n/**\n * A helper type used in the definition of {@link AggregatePropsOnly}.\n */\nexport type AggregatePropsOnlyHelper<T extends QuerySelect> = {\n    [K in keyof T]: T[K] extends QueryColumn<any> ? never : K;\n};\n\n/**\n * The names of properties from a `select` object that refer to aggregated values.\n * Compare with {@link ColumnPropsOnly}.\n */\nexport type AggregatePropsOnly<T extends QuerySelect> = AggregatePropsOnlyHelper<T>[keyof AggregatePropsOnlyHelper<T>];\n\n/**\n * Returns the names of properties in a query that refer to aggregated columns.\n * The result is an array of strings, but type-constrained to string literal types:\n *\n * ```ts\n * getAggregatePropsOnly({\n *    customer: Customer.Name,\n *    spend: Invoice.Amount.sum()\n * }) // [\"spend\"]\n * ```\n *\n * @param select the `select` object from a query\n */\nexport function getAggregatePropsOnly<T extends QuerySelect>(select: T) {\n    const keys = keysOf(select).filter((x) => !(select[x] instanceof QueryColumn));\n    return keys as AggregatePropsOnly<T>[];\n}\n\n/**\n * An object that contains a subset of the the named properties from a query's\n * `select` object, those that refer to aggregated values (hence all are of\n * type `number`.)\n */\nexport type AggregateValuesOnly<T extends QuerySelect> = {\n    [K in AggregatePropsOnly<T>]: number;\n};\n\nexport type CalculationValues<C extends QueryCalculations<any>> = {\n    [K in keyof C]: number;\n};\n\n/**\n * A helper type used in the definition of {@link ColumnPropsOnly}.\n */\nexport type ColumnPropsOnlyHelper<T extends QuerySelect> = {\n    [K in keyof T]: T[K] extends QueryColumn<any> ? K : never;\n};\n\n/**\n * The names of properties from a `select` object that refer to plain columns.\n * Compare with {@link AggregatePropsOnly}.\n */\nexport type ColumnPropsOnly<T extends QuerySelect> = ColumnPropsOnlyHelper<T>[keyof ColumnPropsOnlyHelper<T>];\n\n/**\n * Returns the names of properties in a query that refer to plain columns. The\n * result is an array of strings, but type-constrained to string literal types:\n *\n * ```ts\n * getColumnPropsOnly({\n *    customer: Customer.Name,\n *    spend: Invoice.Amount.sum()\n * }) // [\"customer\"]\n * ```\n *\n * @param select the `select` object from a query\n */\nexport function getColumnPropsOnly<T extends QuerySelect>(select: T) {\n    const keys = keysOf(select).filter((x) => select[x] instanceof QueryColumn);\n    return keys as ColumnPropsOnly<T>[];\n}\n\n/**\n * Returns the plain column objects referred to in a query, ignoring\n * aggregated columns.\n * @param select the `select` object from a query\n */\nexport function getColumnsOnly(select: QuerySelect) {\n    return keysOf(select)\n        .map((k) => select[k])\n        .filter((x) => x instanceof QueryColumn)\n        .map((x) => x as QueryColumn<any>);\n}\n\nexport type Calculation<S extends QuerySelect> = number | AggregatePropsOnly<S> | [Calculation<S>, \"+\" | \"-\" | \"*\" | \"/\" | \"??\", Calculation<S>];\n\n/**\n * The `select` object of a query has named properties of type {@link SelectMember}.\n */\nexport type QueryCalculations<S extends QuerySelect> = Record<string, Calculation<S>>;\n\nexport type Ordering<S extends QuerySelect, C extends QueryCalculations<S>> = { descending?: boolean } & (\n    | {\n          select: keyof S;\n      }\n    | {\n          calculation: keyof C;\n      }\n);\n\n/**\n * Strongly-typed query definition: use {@link jsonifyQuery} to convert to the JSON format\n * and {@link expandQueryResult} to generate corresponding output records.\n */\nexport interface Query<S extends QuerySelect, C extends QueryCalculations<S>> {\n    select: S;\n    filters?: FilterJson[];\n    calculations?: C;\n    /**\n     * Ordering criteria to apply.\n     */\n    orderBy?: (OrderingJson | Ordering<S, C>)[];\n    /**\n     * Specifies whether to return a `totals` property containing the\n     * aggregation values across the whole dataset, e.g. if the `select`\n     * object is:\n     *\n     * ```ts\n     * {\n     *    customer: Customer.Name,\n     *    spend: Invoice.Amount.sum()\n     * }\n     * ```\n     *\n     * the returned `records` will have properties `customer` and `spend`,\n     * one per customer. Specify `totals: true` to also get a `totals` object\n     * with only a `spend` property, containing the total spend across all\n     * customers.\n     */\n    totals?: boolean;\n    /**\n     * Number of result records to skip before the first record returned.\n     */\n    skip?: number;\n    /**\n     * Number of result records to return.\n     */\n    take?: number;\n    /**\n     * A string to insert in a comment at the start of the generated SQL.\n     *\n     * This will be aggressively processed to remove the danger of injection\n     * attacks, so anything other than alpha, numeric, new line or CR\n     * characters will be replaced with space.\n     */\n    comment?: string;\n    /**\n     * Only applicable if the query specifies only ordinary columns, no\n     * aggregations. If true, no GROUP BY clause is added to the SQL, so if\n     * multiple results have the same values they will appear repeatedly in\n     * the output. This can greatly reduce the work required by the SQL\n     * engine, and so should be specified if duplicate rows are tolerable or\n     * are known to be impossible.\n     */\n    allowDuplicates?: boolean;\n    /**\n     * If false, the number of rows returned will be limited by the first\n     * aggregation. This is probably not desirable and it would be better if\n     * this option defaulted to true, but it defaults to false for absolute\n     * backward compatibility.\n     */\n    fullJoins?: boolean;\n}\n"]},"metadata":{},"sourceType":"script"}