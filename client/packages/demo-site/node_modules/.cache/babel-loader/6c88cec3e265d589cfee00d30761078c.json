{"ast":null,"code":"\"use strict\";\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.smartDates = exports.fillDates = exports.detectDateType = exports.dateTypes = void 0;\n\nvar moment_1 = __importDefault(require(\"moment\"));\n\nfunction parseDate(val) {\n  // Ensure a numeric year is not interpreted as offset from 1970!\n  if (typeof val === \"number\") {\n    val = \"\" + val;\n  }\n\n  return (0, moment_1.default)(val);\n}\n\nvar days = {\n  round: function round(d) {\n    return d.clone().startOf(\"day\");\n  },\n  format: function format(d) {\n    return d.format(\"ll\");\n  },\n  increment: function increment(d) {\n    return d.clone().add(1, \"day\");\n  }\n};\nvar months = {\n  round: function round(d) {\n    return d.clone().startOf(\"month\");\n  },\n  format: function format(d) {\n    return d.format(\"MMM YYYY\");\n  },\n  increment: function increment(d) {\n    return d.clone().add(1, \"month\");\n  }\n};\nvar quarters = {\n  round: function round(d) {\n    return d.clone().startOf(\"quarter\");\n  },\n  format: function format(d) {\n    var monthFirst = d.format(\"MMM\");\n    var monthLast = d.clone().add(2, \"months\").format(\"MMM\");\n    var year = d.format(\"YYYY\");\n    return \"\".concat(monthFirst, \"-\").concat(monthLast, \" \").concat(year);\n  },\n  increment: function increment(d) {\n    return d.clone().add(3, \"months\");\n  }\n};\nvar years = {\n  round: function round(d) {\n    return d.clone().startOf(\"year\");\n  },\n  format: function format(d) {\n    return d.format(\"YYYY\");\n  },\n  increment: function increment(d) {\n    return d.clone().add(1, \"year\");\n  }\n};\n/**\n * Standard built-in date types. To customise, implement the {@link FillDateType} interface.\n */\n\nexports.dateTypes = {\n  days: days,\n  months: months,\n  quarters: quarters,\n  years: years\n};\n/**\n * Examines a set of dates and chooses the most specific type that includes them all. If\n * all fall on Jan, 1 then `years` is chosen, and so on.\n */\n\nfunction detectDateType(dates) {\n  return !dates.every(function (x) {\n    return x.date() === 1;\n  }) ? exports.dateTypes.days : !dates.every(function (x) {\n    return x.month() % 3 === 0;\n  }) ? exports.dateTypes.months : !dates.every(function (x) {\n    return x.month() === 0;\n  }) ? exports.dateTypes.quarters : exports.dateTypes.years;\n}\n\nexports.detectDateType = detectDateType;\n/**\n * When querying for a time series chart, e.g. x-axis is _Month_ and y-axis is\n * _Total Sales_, there may be months where nothing was sold so they are\n * missing from the list of records.\n *\n * To render a proper time-series, we need these gaps to be filled in with\n * runs of fake records that give zero amounts for those months. e.g.\n *\n * ```ts\n * const filled = fillDates({\n *     records: [\n *         { date: '2020-04-01', totalSales: 10 },\n *         { date: '2020-06-01', totalSales: 4 },\n *         { date: '2020-07-01', totalSales: 9 },\n *     ],\n *     type: dateTypes.months,\n *     getDate: rec => rec.date,\n *     fill: (label, rec) => ({\n *         label,\n *         totalSales: 0,\n *         ...rec\n *     })\n * });\n * ```\n *\n * In the above example we add a `label` property to all the records, and\n * for the records that fill the gaps we set the `totalSales` property to 0.\n * For the real records, `...rec` will copy the real value of `totalSales`.\n *\n * To do this, we need to know:\n *\n * - how to round a date to the start of a unit (year, month, quarter),\n * - how to increment a date by that unit,\n * - how to format a date to a string for display.\n *\n * These operations are encapsulated by the {@link FillDateType} interface.\n * Several built-in types are provided in {@link dateTypes}, but you can\n * implement your own.\n *\n * Optionally you can also pass `min` and `max` dates, which will cause\n * extra records to be added at the start and end of the range if necessary.\n *\n * If you don't pass a `type`, a suitable type will be detected based on\n * how the input record dates fall on unit boundaries.\n */\n\nfunction fillDates(_a) {\n  var records = _a.records,\n      getDate = _a.getDate,\n      fill = _a.fill,\n      min = _a.min,\n      max = _a.max,\n      type = _a.type;\n  records = __spreadArray([], records, true);\n  records.sort(function (x, y) {\n    return parseDate(getDate(x)).diff(parseDate(getDate(y)));\n  });\n  type = type !== null && type !== void 0 ? type : detectDateType(records.map(function (d) {\n    return parseDate(getDate(d));\n  }));\n  var results = [];\n  var latest = undefined;\n  var lower = min ? type.round(parseDate(min)) : undefined;\n\n  for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {\n    var record = records_1[_i];\n    var d = getDate(record);\n    if (!d) continue;\n    var current = parseDate(d);\n\n    for (;;) {\n      latest = latest ? type.increment(latest) : lower;\n\n      if (!latest || latest >= current) {\n        break;\n      }\n\n      results.push(fill(type.format(latest), undefined));\n    }\n\n    results.push(fill(type.format(current), record));\n    latest = current;\n  }\n\n  if (latest && max) {\n    var upper = type.round(parseDate(max));\n\n    for (;;) {\n      latest = type.increment(latest);\n\n      if (latest > upper) {\n        break;\n      }\n\n      results.push(fill(type.format(latest), undefined));\n    }\n  }\n\n  return results;\n}\n\nexports.fillDates = fillDates;\n/** @deprecated */\n\nfunction smartDates(records, min, max, getDate, fill) {\n  return fillDates({\n    records: records,\n    min: min,\n    max: max,\n    getDate: getDate,\n    fill: fill\n  });\n}\n\nexports.smartDates = smartDates;","map":{"version":3,"mappings":"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","names":["parseDate","val","days","round","d","clone","startOf","format","increment","add","months","quarters","monthFirst","monthLast","year","concat","years","exports","detectDateType","dates","every","x","date","month","fillDates","_a","records","getDate","fill","min","max","type","sort","y","diff","map","results","latest","undefined","lower","_i","record","current","push","upper","smartDates"],"sources":["/Users/alex/Documents/Build/test/flowerbi/client/packages/flowerbi-dates/src/fillDates.ts"],"sourcesContent":["import moment, { Moment } from \"moment\";\n\nexport type FillDate = Date | string | number | Moment;\n\nfunction parseDate(val: FillDate) {\n    // Ensure a numeric year is not interpreted as offset from 1970!\n    if (typeof val === \"number\") {\n        val = \"\" + val;\n    }\n\n    return moment(val);\n}\n\n/**\n * Three operations on dates used by {@link fillDates}.\n */\nexport type FillDateType = {\n    /** Round the given date down to the nearest whole unit (e.g. start of month, quarter, year) */\n    round(d: Moment): Moment;\n    /** Format the given date to a string */\n    format(d: Moment): string;\n    /** Increment the date by the unit. The given date will already be rounded down. */\n    increment(d: Moment): Moment;\n};\n\nconst days: FillDateType = {\n    round(d) {\n        return d.clone().startOf(\"day\");\n    },\n    format(d) {\n        return d.format(\"ll\");\n    },\n    increment(d) {\n        return d.clone().add(1, \"day\");\n    },\n};\n\nconst months: FillDateType = {\n    round(d) {\n        return d.clone().startOf(\"month\");\n    },\n    format(d) {\n        return d.format(\"MMM YYYY\");\n    },\n    increment(d) {\n        return d.clone().add(1, \"month\");\n    },\n};\n\nconst quarters: FillDateType = {\n    round(d) {\n        return d.clone().startOf(\"quarter\");\n    },\n    format(d) {\n        const monthFirst = d.format(\"MMM\");\n        const monthLast = d.clone().add(2, \"months\").format(\"MMM\");\n        const year = d.format(\"YYYY\");\n        return `${monthFirst}-${monthLast} ${year}`;\n    },\n    increment(d) {\n        return d.clone().add(3, \"months\");\n    },\n};\n\nconst years: FillDateType = {\n    round(d) {\n        return d.clone().startOf(\"year\");\n    },\n    format(d) {\n        return d.format(\"YYYY\");\n    },\n    increment(d) {\n        return d.clone().add(1, \"year\");\n    },\n};\n\n/**\n * Standard built-in date types. To customise, implement the {@link FillDateType} interface.\n */\nexport const dateTypes = {\n    days,\n    months,\n    quarters,\n    years,\n} as const;\n\n/**\n * Examines a set of dates and chooses the most specific type that includes them all. If\n * all fall on Jan, 1 then `years` is chosen, and so on.\n */\nexport function detectDateType(dates: Moment[]): FillDateType {\n    return !dates.every((x) => x.date() === 1)\n        ? dateTypes.days\n        : !dates.every((x) => x.month() % 3 === 0)\n        ? dateTypes.months\n        : !dates.every((x) => x.month() === 0)\n        ? dateTypes.quarters\n        : dateTypes.years;\n}\n\n/** Options for {@link fillDates} function. */\nexport interface FillDatesOptions<T, R> {\n    /** The records to base the filled list on. */\n    records: T[];\n    /** The operations to use for rounding, incrementing and formatting dates. */\n    type?: FillDateType;\n    /** Extracts a date value from a record in the input list. */\n    getDate(record: T): FillDate;\n    /**\n     * Generate a record for a date, from the formatted {@link dateText} and\n     * the input record for that date, if any.\n     */\n    fill(dateText: string, record: T | undefined): R;\n    /**\n     * The minimum date to generate. It will be rounded down by the {@link type}\n     * so doesn't need to be on an exact boundary.\n     */\n    min?: FillDate;\n    /**\n     * The maximum date to generate. It will be rounded down by the {@link type}\n     * so doesn't need to be on an exact boundary.\n     */\n    max?: FillDate;\n}\n\n/**\n * When querying for a time series chart, e.g. x-axis is _Month_ and y-axis is\n * _Total Sales_, there may be months where nothing was sold so they are\n * missing from the list of records.\n *\n * To render a proper time-series, we need these gaps to be filled in with\n * runs of fake records that give zero amounts for those months. e.g.\n *\n * ```ts\n * const filled = fillDates({\n *     records: [\n *         { date: '2020-04-01', totalSales: 10 },\n *         { date: '2020-06-01', totalSales: 4 },\n *         { date: '2020-07-01', totalSales: 9 },\n *     ],\n *     type: dateTypes.months,\n *     getDate: rec => rec.date,\n *     fill: (label, rec) => ({\n *         label,\n *         totalSales: 0,\n *         ...rec\n *     })\n * });\n * ```\n *\n * In the above example we add a `label` property to all the records, and\n * for the records that fill the gaps we set the `totalSales` property to 0.\n * For the real records, `...rec` will copy the real value of `totalSales`.\n *\n * To do this, we need to know:\n *\n * - how to round a date to the start of a unit (year, month, quarter),\n * - how to increment a date by that unit,\n * - how to format a date to a string for display.\n *\n * These operations are encapsulated by the {@link FillDateType} interface.\n * Several built-in types are provided in {@link dateTypes}, but you can\n * implement your own.\n *\n * Optionally you can also pass `min` and `max` dates, which will cause\n * extra records to be added at the start and end of the range if necessary.\n *\n * If you don't pass a `type`, a suitable type will be detected based on\n * how the input record dates fall on unit boundaries.\n */\nexport function fillDates<T, R>({ records, getDate, fill, min, max, type }: FillDatesOptions<T, R>) {\n    records = [...records];\n    records.sort((x, y) => parseDate(getDate(x)).diff(parseDate(getDate(y))));\n\n    type = type ?? detectDateType(records.map((d) => parseDate(getDate(d))));\n\n    const results: R[] = [];\n    let latest: Moment | undefined = undefined;\n    const lower = min ? type.round(parseDate(min)) : undefined;\n\n    for (const record of records) {\n        const d = getDate(record);\n        if (!d) continue;\n\n        const current = parseDate(d);\n\n        for (;;) {\n            latest = latest ? type.increment(latest) : lower;\n            if (!latest || latest >= current) {\n                break;\n            }\n\n            results.push(fill(type.format(latest), undefined));\n        }\n\n        results.push(fill(type.format(current), record));\n        latest = current;\n    }\n\n    if (latest && max) {\n        const upper = type.round(parseDate(max));\n        for (;;) {\n            latest = type.increment(latest);\n            if (latest > upper) {\n                break;\n            }\n\n            results.push(fill(type.format(latest), undefined));\n        }\n    }\n\n    return results;\n}\n\n/** @deprecated */\nexport function smartDates<T, R>(\n    records: T[],\n    min: FillDate | undefined,\n    max: FillDate | undefined,\n    getDate: (record: T) => FillDate,\n    fill: (dateText: string, record: T | undefined) => R\n) {\n    return fillDates({ records, min, max, getDate, fill });\n}\n"]},"metadata":{},"sourceType":"script"}