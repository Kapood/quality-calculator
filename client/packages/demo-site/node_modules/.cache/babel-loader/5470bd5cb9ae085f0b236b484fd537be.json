{"ast":null,"code":"import { jsonDateParser } from \"json-date-parser\";\nimport { getDb } from \"./database\";\n\nasync function querySql(sql) {\n  const db = await getDb();\n  const started = new Date();\n  const result = JSON.stringify(db.exec(sql));\n  const finished = new Date();\n  console.log(`SQL query took ${finished.getTime() - started.getTime()} ms`);\n\n  if (sql.includes(\"allbugs\")) {\n    console.log(sql);\n  }\n\n  return result;\n}\n\nwindow.querySql = querySql;\nconst blazorReady = new Promise(done => window.notifyBlazorReady = done);\nexport async function localFetch(queryJson) {\n  await blazorReady;\n  const started = new Date();\n  const json = await DotNet.invokeMethodAsync(\"FlowerBI.WasmHost\", \"Query\", JSON.stringify(queryJson));\n  const finished = new Date();\n  console.log(queryJson.comment, `Blazor + SQL query took ${finished.getTime() - started.getTime()} ms`, queryJson);\n  const parsed = JSON.parse(json, jsonDateParser);\n\n  if (parsed.stackTrace) {\n    console.error(parsed);\n    return {\n      records: []\n    };\n  }\n\n  if (!parsed[0]) {\n    console.error(parsed);\n    return {\n      records: []\n    };\n  }\n\n  const columns = parsed[0].columns;\n  const values = parsed[0].values;\n  const firstValueIndex = columns.indexOf(\"Value0\");\n  const endOfSelects = firstValueIndex === -1 ? columns.length : firstValueIndex;\n  const result = {\n    records: values.map(x => ({\n      selected: x.slice(0, endOfSelects),\n      aggregated: x.slice(endOfSelects)\n    }))\n  };\n\n  if (parsed[1]) {\n    result.totals = {\n      selected: [],\n      aggregated: parsed[1].values\n    };\n  }\n\n  return result;\n}","map":{"version":3,"sources":["/Users/alex/Documents/Build/test/flowerbi/client/packages/demo-site/src/localFetch.ts"],"names":["jsonDateParser","getDb","querySql","sql","db","started","Date","result","JSON","stringify","exec","finished","console","log","getTime","includes","window","blazorReady","Promise","done","notifyBlazorReady","localFetch","queryJson","json","DotNet","invokeMethodAsync","comment","parsed","parse","stackTrace","error","records","columns","values","firstValueIndex","indexOf","endOfSelects","length","map","x","selected","slice","aggregated","totals"],"mappings":"AAAA,SAASA,cAAT,QAA+B,kBAA/B;AACA,SAASC,KAAT,QAAsB,YAAtB;;AAGA,eAAeC,QAAf,CAAwBC,GAAxB,EAAqC;AAEjC,QAAMC,EAAE,GAAG,MAAMH,KAAK,EAAtB;AAEA,QAAMI,OAAO,GAAG,IAAIC,IAAJ,EAAhB;AACA,QAAMC,MAAM,GAAGC,IAAI,CAACC,SAAL,CAAeL,EAAE,CAACM,IAAH,CAAQP,GAAR,CAAf,CAAf;AACA,QAAMQ,QAAQ,GAAG,IAAIL,IAAJ,EAAjB;AACAM,EAAAA,OAAO,CAACC,GAAR,CAAa,kBAAiBF,QAAQ,CAACG,OAAT,KAAqBT,OAAO,CAACS,OAAR,EAAkB,KAArE;;AACA,MAAIX,GAAG,CAACY,QAAJ,CAAa,SAAb,CAAJ,EAA6B;AACzBH,IAAAA,OAAO,CAACC,GAAR,CAAYV,GAAZ;AACH;;AACD,SAAOI,MAAP;AACH;;AAEAS,MAAD,CAAgBd,QAAhB,GAA2BA,QAA3B;AAEA,MAAMe,WAAW,GAAG,IAAIC,OAAJ,CAAYC,IAAI,IAAKH,MAAD,CAAgBI,iBAAhB,GAAoCD,IAAxD,CAApB;AAEA,OAAO,eAAeE,UAAf,CAA0BC,SAA1B,EAA0E;AAE7E,QAAML,WAAN;AAEA,QAAMZ,OAAO,GAAG,IAAIC,IAAJ,EAAhB;AACA,QAAMiB,IAAI,GAAG,MAAMC,MAAM,CAACC,iBAAP,CACf,mBADe,EACM,OADN,EACejB,IAAI,CAACC,SAAL,CAAea,SAAf,CADf,CAAnB;AAGA,QAAMX,QAAQ,GAAG,IAAIL,IAAJ,EAAjB;AACAM,EAAAA,OAAO,CAACC,GAAR,CAAYS,SAAS,CAACI,OAAtB,EAAgC,2BAA0Bf,QAAQ,CAACG,OAAT,KAAqBT,OAAO,CAACS,OAAR,EAAkB,KAAjG,EAAuGQ,SAAvG;AAEA,QAAMK,MAAM,GAAGnB,IAAI,CAACoB,KAAL,CAAWL,IAAX,EAAiBvB,cAAjB,CAAf;;AAEA,MAAI2B,MAAM,CAACE,UAAX,EAAuB;AACnBjB,IAAAA,OAAO,CAACkB,KAAR,CAAcH,MAAd;AACA,WAAO;AAAEI,MAAAA,OAAO,EAAE;AAAX,KAAP;AACH;;AAED,MAAI,CAACJ,MAAM,CAAC,CAAD,CAAX,EAAgB;AACZf,IAAAA,OAAO,CAACkB,KAAR,CAAcH,MAAd;AACA,WAAO;AAAEI,MAAAA,OAAO,EAAE;AAAX,KAAP;AACH;;AAED,QAAMC,OAAO,GAAGL,MAAM,CAAC,CAAD,CAAN,CAAUK,OAA1B;AACA,QAAMC,MAAM,GAAGN,MAAM,CAAC,CAAD,CAAN,CAAUM,MAAzB;AACA,QAAMC,eAAe,GAAGF,OAAO,CAACG,OAAR,CAAgB,QAAhB,CAAxB;AACA,QAAMC,YAAY,GAAGF,eAAe,KAAK,CAAC,CAArB,GAAyBF,OAAO,CAACK,MAAjC,GAA0CH,eAA/D;AAEA,QAAM3B,MAAuB,GAAG;AAC5BwB,IAAAA,OAAO,EAAEE,MAAM,CAACK,GAAP,CAAWC,CAAC,KAAK;AACtBC,MAAAA,QAAQ,EAAED,CAAC,CAACE,KAAF,CAAQ,CAAR,EAAWL,YAAX,CADY;AAEtBM,MAAAA,UAAU,EAAEH,CAAC,CAACE,KAAF,CAAQL,YAAR;AAFU,KAAL,CAAZ;AADmB,GAAhC;;AAOA,MAAIT,MAAM,CAAC,CAAD,CAAV,EAAe;AACXpB,IAAAA,MAAM,CAACoC,MAAP,GAAgB;AACZH,MAAAA,QAAQ,EAAE,EADE;AAEZE,MAAAA,UAAU,EAAEf,MAAM,CAAC,CAAD,CAAN,CAAUM;AAFV,KAAhB;AAIH;;AAED,SAAO1B,MAAP;AACH","sourcesContent":["import { jsonDateParser } from \"json-date-parser\";\nimport { getDb } from \"./database\";\nimport { QueryResultJson, QuerySelectValue, QueryJson } from \"flowerbi\";\n\nasync function querySql(sql: string) {\n    \n    const db = await getDb();\n\n    const started = new Date();\n    const result = JSON.stringify(db.exec(sql));\n    const finished = new Date();\n    console.log(`SQL query took ${finished.getTime() - started.getTime()} ms`);\n    if (sql.includes(\"allbugs\")) {\n        console.log(sql);\n    }\n    return result;\n}\n\n(window as any).querySql = querySql;\n\nconst blazorReady = new Promise(done => (window as any).notifyBlazorReady = done);\n\nexport async function localFetch(queryJson: QueryJson): Promise<QueryResultJson> {\n\n    await blazorReady;\n\n    const started = new Date();    \n    const json = await DotNet.invokeMethodAsync(\n        \"FlowerBI.WasmHost\", \"Query\", JSON.stringify(queryJson)\n    ) as string;    \n    const finished = new Date();\n    console.log(queryJson.comment, `Blazor + SQL query took ${finished.getTime() - started.getTime()} ms`, queryJson);\n\n    const parsed = JSON.parse(json, jsonDateParser);\n\n    if (parsed.stackTrace) {\n        console.error(parsed);\n        return { records: [] };\n    }\n\n    if (!parsed[0]) {\n        console.error(parsed);\n        return { records: [] };\n    }\n\n    const columns = parsed[0].columns;\n    const values = parsed[0].values as QuerySelectValue[][];\n    const firstValueIndex = columns.indexOf(\"Value0\");\n    const endOfSelects = firstValueIndex === -1 ? columns.length : firstValueIndex;\n\n    const result: QueryResultJson = {\n        records: values.map(x => ({\n            selected: x.slice(0, endOfSelects),\n            aggregated: x.slice(endOfSelects) as number[]\n        }))\n    };\n    \n    if (parsed[1]) {\n        result.totals = {\n            selected: [],\n            aggregated: parsed[1].values\n        };\n    }\n\n    return result;\n}\n"]},"metadata":{},"sourceType":"module"}