{"ast":null,"code":"import _toConsumableArray from\"/Users/alex/Documents/Build/test/flowerbi/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";import React,{useRef}from\"react\";import{distinct,keysOf}from\"flowerbi\";import{useQuery}from\"flowerbi-react\";import{FlowerBIChartBox}from\"flowerbi-react-utils\";import{Bug,Workflow,CategoryCombination}from\"../demoSchema\";import{dataColours}from\"./dataColours\";import{Bar}from\"react-chartjs-2\";import{jsx as _jsx}from\"react/jsx-runtime\";var categoriesRaw={\"Crashed\":CategoryCombination.Crashed,\"Data loss\":CategoryCombination.DataLoss,\"Security breach\":CategoryCombination.SecurityBreach,\"Off by one\":CategoryCombination.OffByOne,\"Slow\":CategoryCombination.Slow,\"Stack overflow\":CategoryCombination.StackOverflow};var categories=categoriesRaw;export function TypesOfError(_ref){var pageFilters=_ref.pageFilters,fetch=_ref.fetch;var id=\"TypesOfError\";// In the query we ask for the bits describing the categories applicable to each bug\nvar query={select:{categoryBits:Bug.CategoryCombinationId,workflowState:Workflow.WorkflowState,bugCount:Bug.Id.count()},filters:[Workflow.Resolved.equalTo(true)].concat(_toConsumableArray(pageFilters.getFilters(id)))};var data=useQuery(fetch,query);var chart=useRef(null);var distinctWorkflowStates=distinct(data.records.map(function(r){return r.workflowState;}));// Convert the bit combinations into category labels\nvar bugCountByStateAndCategory=distinctWorkflowStates.flatMap(function(workflowState){return keysOf(categories).map(function(category,bit){return{workflowState:workflowState,category:category,bugCount:data.records.filter(function(r){return r.workflowState===workflowState&&r.categoryBits&1<<bit;}).map(function(r){return r.bugCount;}).reduce(function(l,r){return l+r;},0)};});});// Sum up the categories (full height of each bar)\nvar bugCountByCategory=keysOf(categories).map(function(category){return{category:category,bugCount:bugCountByStateAndCategory.filter(function(r){return r.category===category;}).map(function(r){return r.bugCount;}).reduce(function(l,r){return l+r;},0)};});// Sort by bugCount descending so tallest bar is first\nbugCountByCategory.sort(function(x,y){return y.bugCount-x.bugCount;});// Omit empty categories\nvar orderedCategories=bugCountByCategory.filter(function(c){return c.bugCount>0;}).map(function(c){return c.category;});return/*#__PURE__*/_jsx(FlowerBIChartBox,{id:id,title:\"Types Of Error\",state:data.state,children:/*#__PURE__*/_jsx(Bar,{ref:chart,options:{scales:{x:{stacked:true},y:{stacked:true,beginAtZero:true}},onClick:function onClick(evt,elements,chart){console.log(\"clicked\",{evt:evt,elements:elements,chart:chart});if(elements[0]){var category=orderedCategories[elements[0].index];var workflowState=distinctWorkflowStates[elements[0].datasetIndex];console.log(\"Category:\",category,\"WorkflowState:\",workflowState);pageFilters.setInteraction(id,[Workflow.WorkflowState.equalTo(workflowState),categories[category].equalTo(true)]);}}},data:{labels:orderedCategories,datasets:distinctWorkflowStates.map(function(workflowState,colour){return{label:workflowState,data:orderedCategories.map(function(category){var _bugCountByStateAndCa,_bugCountByStateAndCa2;return(_bugCountByStateAndCa=(_bugCountByStateAndCa2=bugCountByStateAndCategory.find(function(r){return r.workflowState===workflowState&&r.category===category;}))===null||_bugCountByStateAndCa2===void 0?void 0:_bugCountByStateAndCa2.bugCount)!==null&&_bugCountByStateAndCa!==void 0?_bugCountByStateAndCa:0;}),backgroundColor:dataColours[colour]};})}})});}","map":{"version":3,"sources":["/Users/alex/Documents/Build/test/flowerbi/client/packages/demo-site/src/Reports/TypesOfError.tsx"],"names":["React","useRef","distinct","keysOf","useQuery","FlowerBIChartBox","Bug","Workflow","CategoryCombination","dataColours","Bar","categoriesRaw","Crashed","DataLoss","SecurityBreach","OffByOne","Slow","StackOverflow","categories","TypesOfError","pageFilters","fetch","id","query","select","categoryBits","CategoryCombinationId","workflowState","WorkflowState","bugCount","Id","count","filters","Resolved","equalTo","getFilters","data","chart","distinctWorkflowStates","records","map","r","bugCountByStateAndCategory","flatMap","category","bit","filter","reduce","l","bugCountByCategory","sort","x","y","orderedCategories","c","state","scales","stacked","beginAtZero","onClick","evt","elements","console","log","index","datasetIndex","setInteraction","labels","datasets","colour","label","find","backgroundColor"],"mappings":"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","sourcesContent":["import React, { useRef } from \"react\";\nimport { QueryColumn, distinct, keysOf } from \"flowerbi\";\nimport { useQuery } from \"flowerbi-react\";\nimport { FlowerBIChartBox } from \"flowerbi-react-utils\";\nimport { Bug, Workflow, CategoryCombination } from \"../demoSchema\";\nimport { dataColours } from \"./dataColours\";\nimport { Bar } from \"react-chartjs-2\";\nimport { Chart as ChartJS } from \"chart.js\";\nimport { VisualProps } from \"./VisualProps\";\n\nconst categoriesRaw = {\n    \"Crashed\": CategoryCombination.Crashed,\n    \"Data loss\": CategoryCombination.DataLoss,\n    \"Security breach\": CategoryCombination.SecurityBreach,\n    \"Off by one\": CategoryCombination.OffByOne,\n    \"Slow\": CategoryCombination.Slow,\n    \"Stack overflow\": CategoryCombination.StackOverflow,\n};\n\ntype CategoryLabel = keyof typeof categoriesRaw;\n\nconst categories: Record<CategoryLabel, QueryColumn<boolean>> = categoriesRaw;\n\nexport function TypesOfError({ pageFilters, fetch }: VisualProps) {\n\n    const id = \"TypesOfError\";\n\n    // In the query we ask for the bits describing the categories applicable to each bug\n    const query = {\n        select: {\n            categoryBits: Bug.CategoryCombinationId, \n            workflowState: Workflow.WorkflowState,\n            bugCount: Bug.Id.count()\n        },\n        filters: [\n            Workflow.Resolved.equalTo(true),\n            ...pageFilters.getFilters(id)\n        ]\n    };\n\n    const data = useQuery(fetch, query);\n\n    const chart = useRef<ChartJS<\"bar\">>(null);\n\n    const distinctWorkflowStates = distinct(data.records.map(r => r.workflowState));\n\n    // Convert the bit combinations into category labels\n    const bugCountByStateAndCategory = distinctWorkflowStates.flatMap(workflowState =>\n        keysOf(categories).map((category, bit) => ({\n            workflowState,\n            category,\n            bugCount: data.records\n                .filter(r => r.workflowState === workflowState && r.categoryBits & (1 << bit))\n                .map(r => r.bugCount)\n                .reduce((l, r) => l + r, 0)\n        })));\n\n    // Sum up the categories (full height of each bar)\n    const bugCountByCategory = keysOf(categories).map(category => ({\n        category,\n        bugCount: bugCountByStateAndCategory\n            .filter(r => r.category === category)\n            .map(r => r.bugCount)\n            .reduce((l, r) => l + r, 0)\n    }));\n\n    // Sort by bugCount descending so tallest bar is first\n    bugCountByCategory.sort((x, y) => y.bugCount - x.bugCount);\n\n    // Omit empty categories\n    const orderedCategories = bugCountByCategory.filter(c => c.bugCount > 0).map(c => c.category);\n\n    return (\n        <FlowerBIChartBox id={id} title=\"Types Of Error\" state={data.state}>\n            <Bar \n                ref={chart}\n                options={{ \n                    scales: {\n                        x: { stacked: true },\n                        y: { stacked: true, beginAtZero: true}\n                    },\n                    onClick(evt, elements, chart) {\n                        console.log(\"clicked\", { evt, elements, chart });\n                        if (elements[0]) {\n\n                            const category = orderedCategories[elements[0].index];\n                            const workflowState = distinctWorkflowStates[elements[0].datasetIndex];\n\n                            console.log(\"Category:\", category, \"WorkflowState:\", workflowState);\n                            pageFilters.setInteraction(id, [                                \n                                 Workflow.WorkflowState.equalTo(workflowState), \n                                 categories[category].equalTo(true)                                \n                            ]);\n                        }\n                    }\n                }}\n                data={{\n                    labels: orderedCategories,\n                    datasets: distinctWorkflowStates.map((workflowState, colour) => ({\n                        label: workflowState,\n                        data: orderedCategories.map(category =>\n                            bugCountByStateAndCategory.find(r => r.workflowState === workflowState && \n                                                                 r.category === category)?.bugCount ?? 0),\n                        backgroundColor: dataColours[colour]\n                    }))\n                }}\n            />\n        </FlowerBIChartBox>\n    )\n}\n"]},"metadata":{},"sourceType":"module"}